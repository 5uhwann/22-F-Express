# TEAM 보겸 - 1주차 RBF
## node js란

Node.js는 chrome v8 자바스크립트 엔진으로 빌드 된 자바스크립트 런타임이다.

→ 자바스크립트를 서버에서도 사용할 수 있도록 만든 프로그램

→ v8이라는 자바스크립트 엔진 위에서 동작하는 자바스크립트 런타임(환경)이다. ( 스크립트 언어가 아닌 환경!)

## node js가 나오게 된 이유

자바스크립트를 서버에서도 사용하게 만들기 때문에
→ 한가지 언어로 전체 웹 페이지 만들기 가능!

## **Node 서버 생성**

코어 모듈 사용.

http → 서버 생성, 요청 보냄.

https → SSL 서버
ssL이 무엇이고 왜 중요할 까요?

보안 소켓 계층(Secure Sockets Layer, SSL) 인증서는 종종 디지털 인증서로 불리며, 브라우저(사용자의 컴퓨터)와 서버(웹사이트) 사이의 암호화된 연결을 수립하는 데 사용됩니다.

SSL과 TSL의 정의는?
ssl과 tls는 사용자와 웹 브라우저 간 통신을 암호화하는데 사용하는 프로토콜

tls는 ssl에서 개선된 신규모델 프로토콜이라고 생각하면 된다.

전역으로 expose 하는 특성.

## Node.js 호출

require 함수를 사용해 http 경로를 불러온다.

서버 생성을 위한 createServer()

**createServer()**

requestListener를 인자로 가짐. 들어오는 모든 요청을 실행하는 기능

requestListener 는 IncomingMessage 와 ServerResponse 를 받음.

익명함수를 만들어서 실행 가능

function(req, res), (req, res) ⇒ ()

콜백함수라 부른다.

createServer를 호출하면 서버를 반환하기에 이를 새로운 변수에 저장해두어야함.

그렇지 않으면 생성된 서버의 위치를 특정할 수 없어서 무언가 실행이 불가능함.

**listen()**

반환된 서버에 listen이라는 메서드 사용.

스크립트가 계속 실행되면서 요청을 듣도록 함.

인자로 포트를 받음. 포트는 1000번 대로 가능.

5 면 안될까? (문제 없이 돌아간다. 약속으로 정해둔거 아닐까 생각함)

listen으로 요청을 받도록 하고, local host 포트를 브라우저에서 열면 로딩중 표시가 계속 돌아감.

프로세스가 끝나지 않고 계속 돌아가게 해뒀기 때문

콘솔에는 요청 로그가 남아있음.

const http = require('http');

const server = http.createServer((req, res) => {
  console.log(req);
});

const port = 3000
server.listen(port);

scheme은 URL 제일 앞에 자원에 접근할 방법을 정의해 둔 프로토콜 이름을 적는 자리입니다. scheme:[//[user:password@]host[:port]][/]path[?query][#fragment] 구조가 이렇게 됩니다. scheme 자리에 gopher, telnet, ftp, http, usenet 등이 위치합니다.
잘 알려진 포트 번호의 예로, [20 : FTP(data)]  [21 : FTP(제어)]  [22 : SSH]  [23 : Telnet] [25 : SMTP] [53 : DNS]  [80 : 월드 와이드 웹 HTTP]  [119 : NNTP ] [443 : TLS/SSL 방식의 HTTP] 가 있습니다.


## 요청하기

서버 호출을 위한 포트 생성

요청 객체 console.log로 확인하기

하지만 실제 프로덕트에서는 console.log를 사용하지 않습니다 그 이유는
보안상의 문제 때문입니다. console.log를 사용하면 누구든 쉽게 콘솔창에 접근할 수 있기 때문입니다. 그래서 배포되는 어플리케이션에는 사용하지 않습니다

터미널에 node app.js를 작성하여 루핑 프로세스를 이해하기

## 요청 처리 및 응답 전송

res 호출하고 새로운 헤더 및 write 작성

개발자 도구에서 확인 가능

## 요청과 응답 연결하기

if 조건문을 사용하여 url 파싱하기

사용자에게 요청과 발송 버튼 제공하기

[localhost:3000](http://localhost:3000) 실행 하여, 입력하고 Send 버튼을 누르면
if 문이 종료되고 다음 코드가 나타난다.

## 요청 데이터

직접 서버를 생성하는 on 메서드를 사용해
모든 데이터 이벤트에 실행되는 함수 작성하기

본문 읽을 빈 배열 작성

버퍼를 생성하고, toString을 호출해 문자열로 전환하기

## 라우터를 활용해 여러 파일로 만들기

라우팅하는 이유?

라우팅을 통해서 사용자가 특정한 경로로 들어와서, 특정 요청 메소드를 보낼 때 작동할 로직을 결정할 수 있습니다. 예를 들어 /login 이라는 경로에 들어올 때, GET 메소드라면 로그인 페이지를, POST 메소드라면 로그인을 하는 사용자의 데이터를 보내주는 함수를 실행하도록 하는 것입니다. 이렇게 하면 내가 원하는 로직을 확실하게 만들고 확인할 수 있고, 분할해서 관리할 수 있기 때문에 유지보수가 용이해져 라우팅을 사용하는 것입니다.

routes.js라는 새 파일을 생성하여
기존 app.js에 있던 if문과 기본 응답 코드를 잘라내
작성

app.js와 routes.js 연결을 위한 requestHandler 함수를 작성

qpp.js에서 require를 통해 라우터 불러오기

## **이벤트 루프**

1. node 명령어를 이용해 js 파일을 실행시키면 해당 스크립트를 실행시키게 한다.
2. nodejs는 event loop라는 특별한 성질 때문에 eventListener가 있는 한 절대로 서버가 꺼지지 않고 해당 event 의 요청을 감지하게 된다
3. node js는 싱글 스레드로 실해하여 수천 수만의 요청을 처리하는데 서버가 멈춰 있는 도중 들어올 때마다 실행하기를 반복한다면 처리 속도에 좋지 않다
4. node js는 비동기적으로 처리하기 위해서 이벤트 함수가 있을 때 이벤트 큐에게 넘겨준다

더 자세한 이벤트 루프에 대한 자료 : [https://medium.com/zigbang/nodejs-event-loop파헤치기-16e9290f2b30](https://medium.com/zigbang/nodejs-event-loop%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0-16e9290f2b30)

## **Node.js 백그라운드 확인**

**Single Thread, Event Loop & Blocking Code**

자바 스크립트의 싱글 스레드 사용.

보안문제? 성능문제? 다양한 문제 제기됨.

파일에 대한 요청이 들어올때 뒤의 코드들이 딜레이 되면 다운될 수도 있음.

이벤트 루프가 모든 콜백을 파악하고 코드를 실행함.

파일연산 자체는 이벤트 루프가 해결해주지 못함.

이벤트 루프는 콜백과 빠르게 실행되는 함수만 가져갈 수 있다.

오래 걸리는 작업은 워커풀로 보내진다. 무거운 작업을 담당함.

워커풀은 코드에서 떨어져 다른 여러 스레드에서 작동 가능함.

워커가 작업을 마치면 콜백이 시작되는데, 이 때 작업은 이벤트 루프로 넘겨짐.

내장된 기능.

### **Event Loop**

콜백함수란?
CallBack 함수란 이름 그대로 나중에 호출되는 함수를 말한다. 콜백함수도 일반적인 자바스크립트 함수일 뿐이다. 콜백함수는 코드를 통해 명시적으로 호출하는 함수가 아니라 개발자는 단지 함수를 등록하기만 하고 어떤 이벤트가 발생했거나 특정 시점에 도달했을 때 시스템에서 호출하는 함수를 말한다. 즉 콜백함수는 코로백함수라는 유니크한  문법적 특징을 가지고 있는 게 아니라 호출 방식에 의한 구분이 된다

콜백을 처리하는 순서가 있음.

실행해야하는 타이머 콜백이 있는지 확인함.

타이머가 끝나면 실행될 함수 실행

연산 이후의 콜백 실행.

너무 많은 콜백이 쌓이게 되면 루프 반복을 이어나가지 않고 다음 반복에서 처리함.

열린 콜백을 다 처리하면 Poll 단계로 들어감.

위의 단계를 반복

새로운 I/O 이벤트 찾음.

check 단계 : setImmediate()

close 이벤트 콜백 실행.

process.exit 하기 전에는 이벤트 리스너가 없는지 확인해야됨.

## **Header**

**정의**

먼저 http 헤더는 클라이언트와 서버가 요청 또는 응답으로 부가적인 정보를 전송할 수 있도록 해준다. 메타 데이터이기도 한데 부가적 정보에는 요청자, 컨텐트 타입, 캐싱 등등이 있다

**종류**

Header에는 4가지 종류가 있다

**General header** : 요청과 응답 모두에 적용되지만 바디에서 최종적으로 전송되는 데이터와는 관련이 없는 헤더.

**Request header** : 페치될 리소스나 클라이언트 자체에 대한 자세한 정보를 포함하는 헤더. == 내가 보내는 메세지의 헤더

**Response header** : 위치 또는 서버 자체에 대한 정보(이름, 버전 등)와 같이 응답에 대한 부가적인 정보를 갖는 헤더. == 내가 받은 메세지의 헤더

**Entity header**: 컨텐츠 길이나 MIME 타입과 같이 엔티티 바디에 대한 자세한 정보를 포함하는 헤더. ( 메세지 바디에 관련된 정보)

일반헤더와 엔티티 헤더는 응답 요청에서 공통적으로 사용될 수 있다.

엔티티 헤더에서는 content-type이라고 payload의 데이터 타입을 나타내는 것이 있다

이것은 accept 헤더와 대응한다

### chunk

→데이터 조각

### buffer

→ chunk를 받아주는 용기와 같다 즉 chunk들을 buffer에 채운 후 다 참녀 buffer을 통째로 옮기고 새 buffer에 아직 옮기지 못한 데이터 조각을 다시 채우는 과정은 반복한다

### **stream (스트림)**

→ 데이터 흐름으로 볼 수 있고 buffer가 다 차면 이를 전송하고 다시 buffer를 채우는 버퍼링 작업을 연속하는것

나온 이유 :100MB 용량의 파일을 읽을 때는 메모리 100MB의 버퍼를 만들어야하고 이 작업을 10개만 동시에 해도 메모리가 1GB에 도달하게 되고 서버처럼 다수가 사용할 수 있는 상황에서 메모리 문제가 발생할 수 있다.

이런 문제 떄문에 스트림이 나와서 한번에 100mb가 아니라 조금씩 지속적으로 전달하는 방식

## 구문 오류 (Syntax error)

코드에 오타가 나거나 중괄호를 빼 먹는 등 실행하려 할 때 자동으로 오류가 등장한다. 코드 자체에 빨간 줄이 뜨고 보통 visual code에서 해결책을 마련해주기도 한다

## 런타임 오류

코드를 실행하려 할 때 멈추면서 나는 오류 

에러 메세지가 떠서 에러 메시지를 살피면 해결 가능

→ ex) 예시로 쓰던 코드에 return res.end()를 해주지 않아 밑에 if문에 없는 코드까지 쓰이게 된다면 클라이언트가 발송된 이후에 헤더를 설정 , 오류 발송된 헤더에 문제

## 논리 오류

오류 메시지를 보여주지 않아서 까다로움 원하는 대로 앱 작동이 안되는 오류가 난다. 

ex) 파일에 제대로 입력이 되지 않았다던지

고치는 방법→ 디버거 사용

이런 문제 떄문에 스트림이 나와서 한번에 100mb가 아니라 조금씩 지속적으로 전달하는 방식
**NVM 이 무엇인가?**

[https://codepathfinder.com/entry/NVM-Nodejs-버전-변경하기](https://codepathfinder.com/entry/NVM-Nodejs-%EB%B2%84%EC%A0%84-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0)

nvm이란 ? node.js의 버전을 관리하는 도구
왜 사용하나요? 협업을 할 때 , 다양한 프로젝트를 동시에 진행할 때 버전 호환 문제를 겪을 수 있기에
nvm이 있으면 버전 관리가 쉬워짐
<img width="716" alt="image" src="https://user-images.githubusercontent.com/81469686/191873505-f3d8437b-1cb2-4d18-a4cb-af1831e35442.png">
node version manager.