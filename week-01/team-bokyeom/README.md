# TEAM 보겸 - 1주차 RBF
## node js란

Node.js는 chrome v8 자바스크립트 엔진으로 빌드 된 자바스크립트 런타임이다.

→ 자바스크립트를 서버에서도 사용할 수 있도록 만든 프로그램

→ v8이라는 자바스크립트 엔진 위에서 동작하는 자바스크립트 런타임(환경)이다. ( 스크립트 언어가 아닌 환경!)

## node js가 나오게 된 이유

자바스크립트를 서버에서도 사용하게 만들기 때문에
→ 한가지 언어로 전체 웹 페이지 만들기 가능!

## **Node 서버 생성**

코어 모듈 사용.

http → 서버 생성, 요청 보냄.

https → SSL 서버

전역으로 expose 하는 특성.

## Node.js 호출

require 함수를 사용해 http 경로를 불러온다.

서버 생성을 위한 createServer()

**createServer()**

requestListener를 인자로 가짐. 들어오는 모든 요청을 실행하는 기능

requestListener 는 IncomingMessage 와 ServerResponse 를 받음.

익명함수를 만들어서 실행 가능

function(req, res), (req, res) ⇒ ()

콜백함수라 부른다.

createServer를 호출하면 서버를 반환하기에 이를 새로운 변수에 저장해두어야함.

그렇지 않으면 생성된 서버의 위치를 특정할 수 없어서 무언가 실행이 불가능함.

**listen()**

반환된 서버에 listen이라는 메서드 사용.

스크립트가 계속 실행되면서 요청을 듣도록 함.

인자로 포트를 받음. 포트는 1000번 대로 가능.

5 면 안될까? (문제 없이 돌아간다. 약속으로 정해둔거 아닐까 생각함)

listen으로 요청을 받도록 하고, local host 포트를 브라우저에서 열면 로딩중 표시가 계속 돌아감.

프로세스가 끝나지 않고 계속 돌아가게 해뒀기 때문

콘솔에는 요청 로그가 남아있음.

const http = require('http');

const server = http.createServer((req, res) => {
  console.log(req);
});

const port = 3000
server.listen(port);

## 요청하기

서버 호출을 위한 포트 생성

요청 객체 console.log로 확인하기

터미널에 node app.js를 작성하여 루핑 프로세스를 이해하기

## 요청 처리 및 응답 전송

res 호출하고 새로운 헤더 및 write 작성

개발자 도구에서 확인 가능

## 요청과 응답 연결하기

if 조건문을 사용하여 url 파싱하기

사용자에게 요청과 발송 버튼 제공하기

[localhost:3000](http://localhost:3000) 실행 하여, 입력하고 Send 버튼을 누르면
if 문이 종료되고 다음 코드가 나타난다.

## 요청 데이터

직접 서버를 생성하는 on 메서드를 사용해
모든 데이터 이벤트에 실행되는 함수 작성하기

본문 읽을 빈 배열 작성

버퍼를 생성하고, toString을 호출해 문자열로 전환하기

## 라우터를 활용해 여러 파일로 만들기

routes.js라는 새 파일을 생성하여
기존 app.js에 있던 if문과 기본 응답 코드를 잘라내
작성

app.js와 routes.js 연결을 위한 requestHandler 함수를 작성

qpp.js에서 require를 통해 라우터 불러오기

## **이벤트 루프**

1. node 명령어를 이용해 js 파일을 실행시키면 해당 스크립트를 실행시키게 한다.
2. nodejs는 event loop라는 특별한 성질 때문에 eventListener가 있는 한 절대로 서버가 꺼지지 않고 해당 event 의 요청을 감지하게 된다
3. node js는 싱글 스레드로 실해하여 수천 수만의 요청을 처리하는데 서버가 멈춰 있는 도중 들어올 때마다 실행하기를 반복한다면 처리 속도에 좋지 않다
4. node js는 비동기적으로 처리하기 위해서 이벤트 함수가 있을 때 이벤트 큐에게 넘겨준다

더 자세한 이벤트 루프에 대한 자료 : [https://medium.com/zigbang/nodejs-event-loop파헤치기-16e9290f2b30](https://medium.com/zigbang/nodejs-event-loop%ED%8C%8C%ED%97%A4%EC%B9%98%EA%B8%B0-16e9290f2b30)

## **Node.js 백그라운드 확인**

**Single Thread, Event Loop & Blocking Code**

자바 스크립트의 싱글 스레드 사용.

보안문제? 성능문제? 다양한 문제 제기됨.

파일에 대한 요청이 들어올때 뒤의 코드들이 딜레이 되면 다운될 수도 있음.

이벤트 루프가 모든 콜백을 파악하고 코드를 실행함.

파일연산 자체는 이벤트 루프가 해결해주지 못함.

이벤트 루프는 콜백과 빠르게 실행되는 함수만 가져갈 수 있다.

오래 걸리는 작업은 워커풀로 보내진다. 무거운 작업을 담당함.

워커풀은 코드에서 떨어져 다른 여러 스레드에서 작동 가능함.

워커가 작업을 마치면 콜백이 시작되는데, 이 때 작업은 이벤트 루프로 넘겨짐.

내장된 기능.

### **Event Loop**

콜백을 처리하는 순서가 있음.

실행해야하는 타이머 콜백이 있는지 확인함.

타이머가 끝나면 실행될 함수 실행

연산 이후의 콜백 실행.

너무 많은 콜백이 쌓이게 되면 루프 반복을 이어나가지 않고 다음 반복에서 처리함.

열린 콜백을 다 처리하면 Poll 단계로 들어감.

위의 단계를 반복

새로운 I/O 이벤트 찾음.

check 단계 : setImmediate()

close 이벤트 콜백 실행.

process.exit 하기 전에는 이벤트 리스너가 없는지 확인해야됨.

## **Header**

**정의**

먼저 http 헤더는 클라이언트와 서버가 요청 또는 응답으로 부가적인 정보를 전송할 수 있도록 해준다. 메타 데이터이기도 한데 부가적 정보에는 요청자, 컨텐트 타입, 캐싱 등등이 있다

**종류**

Header에는 4가지 종류가 있다

**General header** : 요청과 응답 모두에 적용되지만 바디에서 최종적으로 전송되는 데이터와는 관련이 없는 헤더.

**Request header** : 페치될 리소스나 클라이언트 자체에 대한 자세한 정보를 포함하는 헤더. == 내가 보내는 메세지의 헤더

**Response header** : 위치 또는 서버 자체에 대한 정보(이름, 버전 등)와 같이 응답에 대한 부가적인 정보를 갖는 헤더. == 내가 받은 메세지의 헤더

**Entity header**: 컨텐츠 길이나 MIME 타입과 같이 엔티티 바디에 대한 자세한 정보를 포함하는 헤더. ( 메세지 바디에 관련된 정보)

일반헤더와 엔티티 헤더는 응답 요청에서 공통적으로 사용될 수 있다.

엔티티 헤더에서는 content-type이라고 payload의 데이터 타입을 나타내는 것이 있다

이것은 accept 헤더와 대응한다

### chunk

→데이터 조각

### buffer

→ chunk를 받아주는 용기와 같다 즉 chunk들을 buffer에 채운 후 다 참녀 buffer을 통째로 옮기고 새 buffer에 아직 옮기지 못한 데이터 조각을 다시 채우는 과정은 반복한다

### **stream (스트림)**

→ 데이터 흐름으로 볼 수 있고 buffer가 다 차면 이를 전송하고 다시 buffer를 채우는 버퍼링 작업을 연속하는것

나온 이유 :100MB 용량의 파일을 읽을 때는 메모리 100MB의 버퍼를 만들어야하고 이 작업을 10개만 동시에 해도 메모리가 1GB에 도달하게 되고 서버처럼 다수가 사용할 수 있는 상황에서 메모리 문제가 발생할 수 있다.

이런 문제 떄문에 스트림이 나와서 한번에 100mb가 아니라 조금씩 지속적으로 전달하는 방식

## 구문 오류 (Syntax error)

코드에 오타가 나거나 중괄호를 빼 먹는 등 실행하려 할 때 자동으로 오류가 등장한다. 코드 자체에 빨간 줄이 뜨고 보통 visual code에서 해결책을 마련해주기도 한다

## 런타임 오류

코드를 실행하려 할 때 멈추면서 나는 오류 

에러 메세지가 떠서 에러 메시지를 살피면 해결 가능

→ ex) 예시로 쓰던 코드에 return res.end()를 해주지 않아 밑에 if문에 없는 코드까지 쓰이게 된다면 클라이언트가 발송된 이후에 헤더를 설정 , 오류 발송된 헤더에 문제

## 논리 오류

오류 메시지를 보여주지 않아서 까다로움 원하는 대로 앱 작동이 안되는 오류가 난다. 

ex) 파일에 제대로 입력이 되지 않았다던지

고치는 방법→ 디버거 사용

이런 문제 떄문에 스트림이 나와서 한번에 100mb가 아니라 조금씩 지속적으로 전달하는 방식
**NVM 이 무엇인가?**

[https://codepathfinder.com/entry/NVM-Nodejs-버전-변경하기](https://codepathfinder.com/entry/NVM-Nodejs-%EB%B2%84%EC%A0%84-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0)

node version manager.