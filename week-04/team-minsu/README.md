# TEAM 민수 - 4주차 RBF

우리가 백엔드 애플리케이션을 구축할때에 코드를 구조화하는 특정 패턴을 따라야합니다. 
<br>⇒ 패턴 : 다른 기능에 따라 코드를 논리적으로 나누는것

# 아키텍처 패턴

## 아키텍처 패턴(Architecture Pattern)이란?

- `소프트웨어의 구조를 패턴화 한 것을 의미합니다.`
- 주어진 문맥 안에서 소프트웨어 아키텍처의 공통적인 발생 문제에 대한 재사용 가능한 해결책을 의미합니다.
- 아키텍처 패턴은 소프트웨어 디자인 패턴과 비슷하지만 더 넓은 범위에 속합니다.ex) MVC Pattern, MVP Pattern, MVVM Pattern,...

## 디자인 패턴(Design Pattern)이란?

- `객체 지향 프로그래밍을 설계할 때 자주 발생하는 문제에 대해서 피하기 위해 사용되는 패턴을 의미합니다.`
- 디자인 패턴은 건축으로 치면 공법에 해당하는 것으로 소프트웨어의 개발 방법을 공식화한 것입니다.
- 소수의 뛰어난 엔지니어가 해결한 문제를 다수의 엔지니어들이 처리할 수 있도록 한 규칙이면서 구현자들 간의 커뮤니케이션의 효율성을 높이는 기법입니다.ex) 생성, 구조, 행위 패턴, …

## 아키텍처 패턴의 종류 이해하기

- 유명한 아키텍처 패턴으로 `MVC, MVP, MVVM` 패턴이 있습니다. 이에 대해서 각각의 아키텍처 패턴에 대한 이해가 필요합니다.

## 📌 MVC-MVP-MVVM 패턴 비교 및 정리

### 1.MVC(Model-View-Controller) 패턴

- `MVC는 Model-View-Controller로 애플리케이션을 세 가지의 계층으로 구분한 방법론을 의미합니다.`
- 사용자가 처음 페이지를 출력하는 경우 Controller로 요청이 발생하고 Model에서 데이터를 가져와서 그 정보를 바탕으로 시각적 표현인 View를 그려주는 아키텍처 패턴을 의미합니다.

#### 1-1. 사용 이유
- 우리가 만들고 있는 프로젝트에 컨트롤러 관련 폴더, 모델이 라우터 함수에 섞여있습니다.<br> 라우팅을 할때 미들웨어 함수를 사용하는데 여기서 실행되는 논리는 컨트롤러 논리입니다.

⇒ 데이터와 교류하고있고 뷰를 반환

- 미리 컨트롤러 논리가 있기에 문제가 되지 않을것 같지만 routes파일에 모두 포함시키는것 보단 여러파일에 나눠 넣는 것이 좋습니다.<br> ⇒ 자칫 큰 파일이 되는것을 막고 + 라우트마다 실행하는 코드가 무엇인지 알 수 있습니다. + 해당하는 컨트롤러 파일과 함수에서 쉽게 알 수 있게 됩니다.

#### 1-2. 구조 계층

- Model
  - 어플리케이션에서 데이터와 busniess logic을 관리하는 계층입니다.
    - business logic : 컴퓨터 프로그램에서 규칙에 따라 데이터를 생성 표시 저장 변경하는 부분 / 데이터처리를 수행하는 응용프로그램의 일부
  - 데이터의 상태가 변경되면 model은 view 및 controller에 알립니다.
    - view에는 최신의 결과를 보여주고
    - controller에는 model의 변화에 따른 적용 가능한 명령을 추가 제거 수정 합니다
  - 객체나 데이터를 나타내는 코드의 한 부분으로
    - 어떤 동작을 수행하는 코드를 말합니다.
  - 표시형식에 의존하지 않아 보여지는 부분에는 신경쓰지 않아도 됩니다. (디스플레이와 분리)
- View
  - 애플리케이션에서 사용자가 직접 보는 화면(UI)을 담당하는 계층을 의미합니다.
  - model로부터 표시할 데이터를 수신합니다.
    - 보여줄 값(model)을 controller로부터 받아와 사용자에게 보여주는 구조입니다.
  - application code와 분리되어 있습니다.
    - view를 생성하기 위해 templete engine에 들어가는 데이터와 약간만 통합되어 있습니다.
    - application code : 실행 프로그램 코드
- Controller
  - view와 model간의 관계를 설정하는 계층이며 해당 부분에서 애플리케이션의 로직을 담당하는 계층을 의미합니다.
  - middleware Function에 분할됩니다.
    - 일부 logic이 분리되어 다른 middleware function으로 이동합니다.
  - 사용자의 입력에 따라 model 및 view를 업데이트 합니다.
    1. 입력이 controller로 전송
    2. controller는 model을 조작하여 업데이트
    3. 업데이트 된 데이터를 view로 전송
  - view에서 가져오는 데이터를 전달하는 경우에도 사용됩니다.
    - 예) 항목 순서를 최저에서 최고 가격으로 변경하는 경우
        - model을 업데이트할 필요없이 controller가 직접 처리합니다.
  - model의 mutator 함수를 호출해 상태를 바꾼다
    - mutator : model의 상태를 변경하는 함수
  - model와 view에 명령을 routing합니다.
  - Routes & Controller
    - Routes는 어떤 경로에 따른 http 메서드에 따라 어떤 Controller 코드를 실행할지 정의합니다.

#### 1-3. 동작 순서

💡  MVC 아키텍처 패턴의 흐름

전체 흐름

```
사용자의 Action → Controller → Model → Controller → View → Controller → View → 사용자 화면
```

상세 흐름

```
1. 사용자의 Action을 Controller에서 받습니다. (사용자 Action → Controller)
2. Controller에서는 이를 확인하고 Model을 업데이트 수행합니다.(Controller → Model)
3. 수정된 값을 Controller로 반환합니다.(Controller ← Model)
4. Controller에서는 View의 수정합니다.(View ← Controller)
5. 사용자에게 변경된 화면을 반환합니다.(사용자 Action ← View)
```

> 참고 - MVC에서 View가 업데이트 되는 방법
>
> - View가 Model을 이용하여 직접 업데이트 하는 방법
> - Model에서 View에게 Notify 하여 업데이트 하는 방법
> - View가 Polling으로 주기적으로 Model의 변경을 감지하여 업데이트 하는 방법.

#### 1-4. 특징

- Controller는 여러개의 View를 선택할 수 있는 1:n 구조입니다.
- Controller는 View를 선택할 뿐 직접 업데이트 하지 않습니다. (View는 Controller를 알지 못합니다.)

#### 1-5. 장점

- MVC 패턴의 장점은 널리 사용되고 있는 패턴이라는 점에 걸맞게 가장 단순합니다. 단순하다 보니 보편적으로 많이 사용되는 디자인패턴입니다.

#### 1-6. 단점

- MVC 패턴의 단점은 View와 Model 사이의 의존성이 높다는 것입니다. View와 Model의 높은 의존성은 어플리케이션이 커질 수록 복잡하지고 유지보수가 어렵게 만들 수 있습니다.



<br><br><br>

### 2.MVP(Model-View-Presenter) 패턴

- MVP 패턴은 Model + View + Presenter를 합친 용어입니다. Model과 View는 MVC 패턴과 동일하고, Controller 대신 Presenter가 존재합니다.

#### 2-1. 구조 계층

- Model : 애플리케이션에서 데이터를 저장하고 처리하는 계층을 의미합니다.
- View : 애플리케이션에서 사용자가 직접 보는 화면(UI)을 담당하는 계층을 의미합니다.
- Presenter : - 해당 계층에서는 뷰와 모델을 완전히 분리하고 서로간의 의존성을 없앴습니다.
  (View - Presenter / Model - Presenter 구조 - 인터페이스로 구성되어 있습니다.) Presenter는 Model을 참조하고 있다가 Update가 발생시 View를 업데이트를 합니다.
  또한 Presenter는 이벤트 발생시 View를 참조해서 Model의 데이터를 업데이트를 합니다.

#### 2-2. 동작 순서

💡  MVP 아키텍처 패턴의 흐름

전체 흐름

```
- 전체 Flow - 사용자의 Action → View → Presenter → Model → Presenter → View → 사용자
```

상세 흐름

```
1. 사용자의 Action을 View에서 받습니다. (사용자 Action → View)
2. View에서는 Presenter로 요청을 합니다. (View → Presenter)
3. Presenter에서는 Model로 데이터를 요청합니다(Presenter → Model)
4. Model은 Presenter로 데이터를 전달합니다.(Model → Presenter)
5. Presenter는 View에게 데이터를 전달합니다.(Presenter → View)
6. View에서 사용자로 화면을 보여줍니다.(View → 사용자)
```

#### 2-3. 특징

- Presenter는 View와 Model의 인스턴스를 가지고 있어 둘을 연결하는 접착제 역할을 합니다.
- Presenter와 View는 1:1 관계입니다.

#### 2-4. 장점

- MVP 패턴의 장점은 View와 Model의 의존성이 없다는 것입니다. MVP 패턴은 MVC 패턴의 단점이었던 View와 Model의 의존성을 해결하였습니다. (Presenter를 통해서만 데이터를 전달 받기 때문에..)

#### 2-5. 단점

- MVC 패턴의 단점인 View와 Model 사이의 의존성은 해결되었지만, View와 Presenter 사이의 의존성이 높은 가지게 되는 단점이 있습니다. 어플리케이션이 복잡해 질 수록 View와 Presenter 사이의 의존성이 강해지는 단점이 있습니다.

<br><br><br>

### 3. MVVM(Model-ViewModel-Model) 패턴

- MVVM은 Model-ViewModel-Model로 애플리케이션을 세 가지의 계층으로 구분한 방법론을 의미합니다.
- View는 ViewModel을 알고 있지만, ViewModel은 View를 알지 못합니다.
- 해당 모델에서는 ViewModel은 Model을 알고 있지만, Model은 ViewModel을 알지 못합니다.

#### 3-1. 구조

- Model : 애플리케이션에서 데이터를 저장하고 처리하는 계층을 의미합니다.
- View : 애플리케이션에서 사용자가 직접 보는 화면(UI)을 담당하는 계층을 의미합니다.
- View Model : 애플리케이션에서 View와 Model 사이에 존재하며 서로간의 중재를 하는 역할을 수행합니다.
  - View - ViewModel : 사용자와의 뷰의 상호작용(클릭, 키보드 등작 등)을 수신하여 이에 대한 처리를 View와 ViewModel을 연결하고 있는 데이터 바인딩을 통해 서로간을 연결합니다.
  - Model - ViewModel: 사용자의 데이터의 변경이 발생하는 경우 데이터를 가져오거나 갱신 한 뒤 View에게 전달하여 사용자에게 전달하는 역할을 수행합니다.

#### 3-2. 동작 순서

💡  MVVM 아키텍처 패턴의 흐름

전체 흐름

```
- 전체 흐름 - 사용자 Action → View → ViewModel → Model → ViewModel → View → 사용자
```

상세 흐름

```
1. 사용자가 입력한 값이 View를 통해 들어옵니다. (사용자 → View)
2. View에 입력값이 들어오면 ViewModel로 입력 값을 전달합니다. (View → ViewModel)
3. 전달받은 ViewModel은 Model에게 데이터 요청을 보냅니다. (ViewModel → Model)
4. Model은 ViewModel에게 요청받은 데이터를 Response 합니다(ViewModel ← Model)
5. ViewModel은 그 값을 처리하여 내부에 저장합니다.
6. View는 ViewModel과의 ‘데이터 바인딩’을 통해 화면상에 표출합니다.(View ↔︎ ViewModel)
```

#### 3-3. 특징

- MVVM 패턴은 Command 패턴과 Data Binding 두 가지 패턴을 사용하여 구현되었습니다.
- Command 패턴과 Data Binding을 이용하여 View와 View Model 사이의 의존성을 없앴습니다.
- View Model과 View는 1:n 관계입니다.

#### 3-4. 장점

- MVVM 패턴은 View와 Model 사이의 의존성이 없습니다. 또한 Command 패턴과 Data Binding을 사용하여 View와 View Model 사이의 의존성 또한 없앤 디자인패턴입니다. 각각의 부분은 독립적이기 때문에 모듈화 하여 개발할 수 있습니다.

#### 2-5. 단점

- MVVM 패턴의 단점은 View Model의 설계가 쉽지 않다는 점입니다.

<br><br>

## 최종 아키텍처 패턴 간의 비교

| 패턴      | 장점                                                                                                                                                                    | 단점                                                                                                                                                                                |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| MVC 패턴  | 단순하고 직관적으로 구조를 파악하기가 가능합니다. 기능별로 코드를 분리하여 하나의 디렉토리에 코드를 모으는 것을 방지하여 가독성과 코드 재 사용성이 좋습니다.            | 핵심 비즈니스 로직이 컨트롤러에 집중되어 있어서 코드 유지 관리에 어려워집니다. View와 Model의 의존성으로 어플리케이션이 커질수록 복잡도가 높아집니다                                |
| MVP 패턴  | 애플리케이션의 모델, 뷰, 프리젠터 레이어가 분리되어 있어 코드 유지 및 테스트가 용이합니다.                                                                              | View와 Presenter가 1:1 관계이기에 서로간의 의존성이 높아집니다.                                                                                                                     |
| MVVM 패턴 | View와 Model 사이의 의존성이 없다 Command 패턴 혹은 데이터 바인딩을 사용하여 View와 ViewModel 사이의 의존성이 없다. 프로젝트 파일을 유지 관리하고 쉽게 변경 할 수 있다. | View와 Model을 설계하는데 쉽지 않다. 이 디자인 아키텍처 패턴은 소규모 프로젝트에는 적합하지 않습니다. 데이터 바인딩 로직이 너무 복잡하면 애플리케이션의 디버깅이 어려워 질 수 있음. |

<br>

# Software Architectural Patterns

MVC 패턴 외 다른 패턴들을 알아보자.

### 1. 계층화 패턴(Layered Pattern)

이 패턴은 n-티어 아키텍쳐 패턴이라 불리며, 하위 모듈들을 그룹화 할 수 있는 구조화 된 프로그램에서 사용된다.

- 일반적인 정보 시스템에서 공통적으로 볼 수 있는 계층
    1. 프레젠테이션 계층 
    2. 애플리케이션 계층
    3. 비즈니스 논리 계층
    4. 데이터 접근 계층

**장점**: 레이어 표준화가 쉽고, 레이어 수준을 정의하기가 수월하다. 레이어들이 독립적이라 변경해도 영향을 끼치지 않는다.

**단점**: 광범위하게 적용 가능하다. 특정 상황에서는 특정 레이어가 불필요하다.

### 2. 클라이언트-서버 패턴(Client-Server pattern)

이 패턴은 하나의 서버와 다수의 클라이언트, 이 두 부분으로  이루어져 있다.

하나의 서버 컴포넌트는 다수의 클라이언트 컴포넌트로 서비스를 전달한다. 클라이언트가 서버에 서비스를 요청하면, 서버는 클라이언트에게 서비스를 제공한다. 

서버는 계속 클라이언트의 요청을 기다린다.

**장점**: 클라이언트가 요청할 수 있는 일련의 서비스를 모델링 할 수 있다

**단점**: 요청은 일반적으로 서버에서 별도의 스레드로 처리된다. 프로세스간 통신은 서로 다른 클라이언트가 서로 다르게 표현되므로 오버헤드가 발생한다.

### 3. 마스터-슬레이브 패턴(Master-Slave pattern)

이 패턴은 마스터와 슬레이브 두 부분으로 이루어져 있다.

마스터 컴포넌트는 동등한 구조를 가진 슬레이브 컴포넌트에게 작업을 분산시킨다. 

**장점**: 정확성 - 서비스의 실행은 각기 다른 구현체를 가진 슬레이브들에게 전파된다

**단점**: 슬레이브가 독립적이므로 공유되는 상태가 없다. 실시간 시스템에서는 마스터-슬레이브간 레이턴시 문제가 발생할 수 있다. 이 패턴은 분리 가능한 문제에만 적용할 수 있다.
### 4. 파이프-필터 패턴(Pipe- Filter pattern)

이 패턴은 데이터 스트림을 생성하고 처리하는 시스템에서 사용할 수 있다.

처리 과정을 담당하는 필터 컴포넌트와 처리된 데이터가 흐르는 파이프 컴포넌트로 이루어져 있다.


**장점**: 동시성 처리를 나타낸다. 입출력이 스트림으로 구성되고 필터가 데이터를 수신하면 연산을 수행하기 시작한다. 필터 추가가 쉽다. 시스템 확장성이 좋다. 필터는 재사용 가능하다. 주어진 필터들을 재구성하여 또 다른 파이프라인을 구축할 수 있다.

**단점**: 가장 느린 필터 연산에 의해 효율성이 제한될 수 있다. 필터간 데이터 이동에서 데이터 변환 오버헤드가 발생한다.
### 5. 브로커 패턴(Broker pattern)

이 패턴은 분리된 컴포넌트로 이루어진 분산 시스템에서 사용된다.

이 패턴은 브로커 컴포넌트가 존재하는데, 이 컴포넌트는 컴포넌트 간의 통신을 조정하는 역할을 한다.


**장점**: 객체의 동적인 변경, 추가, 삭제 및 재할당이 가능하며 개발자에게 배포를 투명하게 만든다.

**단점**: 서비스 표현에 대한 표준화가 필요하다
### 6.피어-투-피어 패턴(Peer-to-peer pattern)

이 패턴에서는 각 컴포넌트를 피어라 칭하고, 피어들은 클라이언트, 서버 역할을 모두 동작할 수 있다.


**장점**: 탈중앙화된 컴퓨팅을 지원한다. 특정 노드 장애에 매우 강하다. 리소스 및 컴퓨팅 성능면에서 확장성이 뛰어나다.

**단점**: 노드들이 자발적으로 참여하기 때문에 서비스 품질에 대한 보장이 어렵다. 보안에 대한 보장이 어렵다. 노드의 갯수에 따라 성능이 좌우된다.
### 7.이벤트-버스 패턴(Event-bus pattern)

이 패턴은 주로 이벤트를 처리하며, 이벤트 소스, 이벤트 리스너, 채널 그리고 이벤트 버스로 구성되어 있다.

소스는 이벤트 버스를 통해 특정 채널로 메시지를 발행하며 (publish),  이벤트 리스너는 특정 채널에서 메시지를 구독한다 (subscribe).  이벤트 리스너는 이전에 구독한 채널에 발행된 메시지에 대해 알림을 받는다.


**장점**: 새로운 발행자 (publishers)와 구독자 (subscribers) 및 연결의 추가가 수월하다. 고도로 분산화된 애플리케이션에 효과적이다.

**단점**: 모든 메시지가 동일한 이벤트 버스를 통해 전달되기 때문에 확장성 문제가 발생할 수 있다.
### 8.블랙보드 패턴(Blackboard pattern)

이 패턴은 3가지 주요 컴포넌트로 이루어져 있다.

1.**블랙보드 (blackboard)** — 솔루션의 객체를 포함하는 구조화된 전역 메모리

2.**지식 소스 (knowledge source)** — 자체 표현을 가진 특수 모듈

3.**제어 컴포넌트 (control component)** — 모듈 선택, 설정 및 실행을 담당한다

모든 컴포넌트는 블랙보드에 접근한다. 컴포넌트는 블랙보드에 새로운 데이터를 생성할 수 있다.

컴포넌트는 블랙보드에서 특정 종류의 데이터를 찾으며, 기존의 지식 소스와의 패턴 매칭으로 데이터를 찾는다. 


**장점**: 새로운 애플리케이션을 쉽게 추가할 수 있다. 데이터 공간의 구조를 쉽게 확장할 수 있다.

**단점**: 모든 애플리케이션이 영향을 받기 때문에 데이터 공간의 구조를 변경하기가 어렵다. 동기화 및 접근 제어가 필요할 수 있다.
### 9.인터프린터 패턴(Interpreter pattern)

이 패턴은 특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계할 때 사용된다. 이는 주로 프로그램의 각 라인을 수행하는 방법을 지정한다. 기본 아이디어는 언어의 각 기호에 대해 클래스를 만드는 것이다


**장점**: 매우 동적인 설계가 가능하다. 최종 사용자가 프로그래밍하기 좋다. 인터프리터 프로그램을 쉽게 교체할 수 있기 때문에 유연성이 향상된다.

**단점**: 인터프리터 언어는 일반적으로 컴파일 언어보다 느리기 때문에 성능 문제가 발생할 수 있다.
