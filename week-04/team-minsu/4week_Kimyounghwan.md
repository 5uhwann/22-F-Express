# week-04

# MVC Pattern

의미: Models, Views, Controllers를 뜻하며, 사용자 인터페이스, 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴이다.

### MVC

1. Models : 데이터와 비즈니스 로직을 관리한다.
    
    **Controller에 의해 업데이트 당한다.**
    
2. Views: 레이아웃과 화면 구현을 처리한다.
    
    
3. Controllers: 입력을 모델과 뷰 부분으로 라우팅한다. 
    
    **Controller는 View를 업데이트 하지 않는다.Only 선택만 한다. (View는 Controller를 알지 못한다.)**
    

**장점**: 가장 단순한 패턴

**단점**: Model과 View 사이의 의존성이 발생한다.(**View 업데이트로 인해 발생한다.**)

 다시 말해 앱이 크고 복잡할수록 유지 보수가 어렵다. 

# Software Architectural Patterns

MVC 패턴 외 다른 패턴들을 알아보자.

### 1. 계층화 패턴(Layered Pattern)

이 패턴은 n-티어 아키텍쳐 패턴이라 불리며, 하위 모듈들을 그룹화 할 수 있는 구조화 된 프로그램에서 사용된다.

- 일반적인 정보 시스템에서 공통적으로 볼 수 있는 계층
    1. 프레젠테이션 계층 
    2. 애플리케이션 계층
    3. 비즈니스 논리 계층
    4. 데이터 접근 계층

**장점**: 레이어 표준화가 쉽고, 레이어 수준을 정의하기가 수월하다. 레이어들이 독립적이라 변경해도 영향을 끼치지 않는다.
**단점**: 광범위하게 적용 가능하다. 특정 상황에서는 특정 레이어가 불필요하다.

### 2. 클라이언트-서버 패턴(Client-Server pattern)

이 패턴은 하나의 서버와 다수의 클라이언트, 이 두 부분으로  이루어져 있다.

하나의 서버 컴포넌트는 다수의 클라이언트 컴포넌트로 서비스를 전달한다. 클라이언트가 서버에 서비스를 요청하면, 서버는 클라이언트에게 서비스를 제공한다. 

서버는 계속 클라이언트의 요청을 기다린다.

**장점**: 클라이언트가 요청할 수 있는 일련의 서비스를 모델링 할 수 있다
**단점**: 요청은 일반적으로 서버에서 별도의 스레드로 처리된다. 프로세스간 통신은 서로 다른 클라이언트가 서로 다르게 표현되므로 오버헤드가 발생한다.

### 3. 마스터-슬레이브 패턴(Master-Slave pattern)

이 패턴은 마스터와 슬레이브 두 부분으로 이루어져 있다.

마스터 컴포넌트는 동등한 구조를 가진 슬레이브 컴포넌트에게 작업을 분산시킨다. 

**장점**: 정확성 - 서비스의 실행은 각기 다른 구현체를 가진 슬레이브들에게 전파된다.
**단점**: 슬레이브가 독립적이므로 공유되는 상태가 없다. 실시간 시스템에서는 마스터-슬레이브간 레이턴시 문제가 발생할 수 있다. 이 패턴은 분리 가능한 문제에만 적용할 수 있다.
### 4. 파이프-필터 패턴(Pipe- Filter pattern)

이 패턴은 데이터 스트림을 생성하고 처리하는 시스템에서 사용할 수 있다.

처리 과정을 담당하는 필터 컴포넌트와 처리된 데이터가 흐르는 파이프 컴포넌트로 이루어져 있다.


**장점**: 동시성 처리를 나타낸다. 입출력이 스트림으로 구성되고 필터가 데이터를 수신하면 연산을 수행하기 시작한다. 필터 추가가 쉽다. 시스템 확장성이 좋다. 필터는 재사용 가능하다. 주어진 필터들을 재구성하여 또 다른 파이프라인을 구축할 수 있다.
**단점**: 가장 느린 필터 연산에 의해 효율성이 제한될 수 있다. 필터간 데이터 이동에서 데이터 변환 오버헤드가 발생한다.
### 5. 브로커 패턴(Broker pattern)

이 패턴은 분리된 컴포넌트로 이루어진 분산 시스템에서 사용된다.

이 패턴은 브로커 컴포넌트가 존재하는데, 이 컴포넌트는 컴포넌트 간의 통신을 조정하는 역할을 한다.


**장점**: 객체의 동적인 변경, 추가, 삭제 및 재할당이 가능하며 개발자에게 배포를 투명하게 만든다.
**단점**: 서비스 표현에 대한 표준화가 필요하다
### 6.피어-투-피어 패턴(Peer-to-peer pattern)

이 패턴에서는 각 컴포넌트를 피어라 칭하고, 피어들은 클라이언트, 서버 역할을 모두 동작할 수 있다.


**장점**: 탈중앙화된 컴퓨팅을 지원한다. 특정 노드 장애에 매우 강하다. 리소스 및 컴퓨팅 성능면에서 확장성이 뛰어나다.
**단점**: 노드들이 자발적으로 참여하기 때문에 서비스 품질에 대한 보장이 어렵다. 보안에 대한 보장이 어렵다. 노드의 갯수에 따라 성능이 좌우된다.
### 7.이벤트-버스 패턴(Event-bus pattern)

이 패턴은 주로 이벤트를 처리하며, 이벤트 소스, 이벤트 리스너, 채널 그리고 이벤트 버스로 구성되어 있다.

소스는 이벤트 버스를 통해 특정 채널로 메시지를 발행하며 (publish),  이벤트 리스너는 특정 채널에서 메시지를 구독한다 (subscribe).  이벤트 리스너는 이전에 구독한 채널에 발행된 메시지에 대해 알림을 받는다.


**장점**: 새로운 발행자 (publishers)와 구독자 (subscribers) 및 연결의 추가가 수월하다. 고도로 분산화된 애플리케이션에 효과적이다.
**단점**: 모든 메시지가 동일한 이벤트 버스를 통해 전달되기 때문에 확장성 문제가 발생할 수 있다.
### 8.블랙보드 패턴(Blackboard pattern)

이 패턴은 3가지 주요 컴포넌트로 이루어져 있다.

1.**블랙보드 (blackboard)** — 솔루션의 객체를 포함하는 구조화된 전역 메모리

2.**지식 소스 (knowledge source)** — 자체 표현을 가진 특수 모듈

3.**제어 컴포넌트 (control component)** — 모듈 선택, 설정 및 실행을 담당한다

모든 컴포넌트는 블랙보드에 접근한다. 컴포넌트는 블랙보드에 새로운 데이터를 생성할 수 있다.

컴포넌트는 블랙보드에서 특정 종류의 데이터를 찾으며, 기존의 지식 소스와의 패턴 매칭으로 데이터를 찾는다. 


**장점**: 새로운 애플리케이션을 쉽게 추가할 수 있다. 데이터 공간의 구조를 쉽게 확장할 수 있다.
**단점**: 모든 애플리케이션이 영향을 받기 때문에 데이터 공간의 구조를 변경하기가 어렵다. 동기화 및 접근 제어가 필요할 수 있다.
### 9.인터프린터 패턴(Interpreter pattern)

이 패턴은 특정 언어로 작성된 프로그램을 해석하는 컴포넌트를 설계할 때 사용된다. 이는 주로 프로그램의 각 라인을 수행하는 방법을 지정한다. 기본 아이디어는 언어의 각 기호에 대해 클래스를 만드는 것이다


**장점**: 매우 동적인 설계가 가능하다. 최종 사용자가 프로그래밍하기 좋다. 인터프리터 프로그램을 쉽게 교체할 수 있기 때문에 유연성이 향상된다.
**단점**: 인터프리터 언어는 일반적으로 컴파일 언어보다 느리기 때문에 성능 문제가 발생할 수 있다.
