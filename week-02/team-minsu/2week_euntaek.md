2주차 학습내용 요약


# 모듈소개

이제 더 빠르게 더 효율적이게

node.js앱을 디버그 하거나 node.js에 일어나고 있는 일을

알 수 있도록 하는 몇 가지 툴을 알아보자

# NPM 스크립트의 이해

NPM = 노드 패키지 매니저 , Node.js 내부에 함께 설치되어 있음.

노드 프로젝트라고 부르는 작업의 초기 내용을 설정가능

Terminal에서

NPM을 실행할 수 있다.

npm초기설정

![화면 캡처 2022-09-22 231759](https://user-images.githubusercontent.com/108321588/192140694-929246d7-13bb-4f74-ba4a-08abdf6098e6.png)


다음과 같이 package.json이 생김 ⇒ 현재 파일 프로젝트의 구성파일

### 구성파일 ⇒ 무슨역할?

위 파일에서 스크립트가 기본값으로 하나있으며

다른 스크립트를 추가하여 실행할수있음

```jsx
"start": "node app.js"
```

스크립트에 다음과 같이 코드작성후 npm start를 하면

node app.js가 실행되어있음. ⇒ node app.js대신 위 명령어만 사용하면 된다. + 다른 협업 개발자들에게 npm start만 실행하게 하면되고 글자수도 어느정도 줄어들었음. + 어느 js파일이 진입파일인지 상관쓰지 않아도 된다.

```jsx
"start-server": "node app.js"
```

위 코드도 node app.js실행이 가능하나 npm start-server를 실행하면 오류가 발생함. ⇒ start는 특수한 경우였음 개별설정된 이름이 있는 일반 스크립트의 경우

npm run 입력 후에 스크립트 이름인

npm run start-server 를 입력해 줘야 서버가 시작된다.

# 제3자 패키지 설치하기

package.json 이 관리 노드 프로젝트에서 제 3자 패키지를 설치할수있다.

⇒ 로컬 프로젝트에는 당연히 코드가 존재+FS 패키지나 이미 사용 중인 HTTP 패키지를 비롯한 여러 코어 노드 패키지를 사용할수있으나

⇒ 충분하지 않다

⇒ 이를 통해 요청을 파싱 , 사용자의 입력 유효성 검사등 작업을 할 수 있음.

npm install nodemon —save-dev → 터미널 입력

node_modules 폴더, package-lock.json 파일이 추가 되었으며

package.json 파일이 업데이트 됨.

# 자동 재시작을 위한 Nodemon 사용

Nodemon 패키지가 설치가 완료 되었는데

그럼 사용은 어떻게 하는것일까?

node app.js를 실행하는 package.json 이 패키지를 통해 노드 애플리케이션을 실행할 수 있게된다.

⇒

start 부분에 node app.js에서 nodemon app.js로 변경

# 다양한 오류 유형 이해

다양한 오류의 유형이 존재한다.

첫번째

### 1.구문오류

코드오타 , 중괄호 생략등의 오류

### 2.런타임 오류

코드를 실행할때 멈춰버리는 상황

### 3.논리적 오류

세 유형중 가장 해결하기 어려움 ⇒ 오류 메세지가 안뜸 + 찾아내기도 힘들다.

⇒ node.js의 디버거를 사용하도록 하자..

해당 파일 선택 > bebug메뉴 start debugging







# Express.js

# 모듈 소개

Express.js ⇒ Node 프로젝트에 제3자 패키지로 설치할 수 있는 프레임워크, 필수적인 작업+세부 내용을 외부에 맡길 수 있도록 도움 + 다수의 유틸리티 함수를 제공 + 훨씬 간단하게 요청과 응답을 처리가능.


# Express.js란?

Express.js는 가장 유명하고 많이 사용된다. Express는 유연하여 특별한기능의 과도한 추가가 필요없다는점 + 애플리케이션을 구축하거나 유입되는 요청들을 처리함에 있어 특정한 방식을 제공해 높은 확장성을 지닌다.

⇒ Express로 구축된 제3자 패키지의수는 수천가지에 달한다. → 크게 새로 구성할 필요없이 Node Express 애플리케이션에 추가할 수 있다.



# 미들웨어란 + 작동방식

Express.js는 미들웨어와 연관이 깊다.

미들웨어 ⇒ 들어오는 요청을 express.js의 다양한 함수를 통해 자동으로 이동하는것.

→ 단일 요청 핸들러 보유 x ⇒ 응답전송 전까지 요청이 통과하게 될 다양한 함수들을 연결할 가능성 확보 ⇒ 이를 하나의 함수로 처리하는 것이 아니라 코드를 다수로 분할할 수 있음.

express 사용

```jsx
import express from "express";
```

use를 사용하면 새로운 미들웨어 함수를 추가할 수 있음.

```jsx
app.use((req, res, next) => {
    console.log('In another middleware!');
    res.send('<h1>Hello from Express!</h1>');
});
```


3가지 인수 ⇒ req, res, next를 받는다.

next는 원래함수로써 Express.js를 통해 여기로 전달되는 함수이며

next인수에 있는 또 다른 함수를 수신 ⇒ 다음 미들웨어로 요청이 이동될 수 있도록함.

유틸리티 함수 send

위와같이 send를 통해 응답을 보내거나 html코드를 전송하거나 any유형의 본문을 첨부할수있음.



# 백그라운드 방식


Github 저장소에서 

response.js 파일을 통해 우리가 호출한 send함수부터 백그라운드에서 어떤 일들이 일어나는지 알 수 있다.

text/html헤더로 되어있을때 내부에서 send가 어떻게 작동되는지 알아보자

우리가 입력한데이터가 문자열? ⇒ 콘텐츠 유형 → html

콘텐츠 유형 헤더가 존재하는지 여부에따라

존재하지 않는다면 자동으로 정해주고 존재한다면 그대로 둔다.

숫자와 같은 다른 값의 경우 이진수 or json데이터로 설정함.


# 라우트

url처리 즉 서버에서 경로를 제어하려는 목적으로 사용한다. ⇒ 연결장치

server.js 한 파일에서만 런칭할 수 있는 것이 아니라 라우터를 통해 여러가지 .js 파일에다가 원하는 코드를 짤 수 있음.

라우터를 사용하는 이유 ⇒ 코드의 간략화 + 가독성

콜백 ⇒ 실행해야하는 함수

하나 이상이 존재할 수도 있으며 다중경로 필터를 설정할 수도 있음.

이러한 콜백은 `next('route')`
를 호출하여 나머지 라우트 콜백을 우회할 수 있음.

라우트에 대한 사전 조건을 지정한 후, 현재의 라우트를 계속할 이유가 없는 경우에는 제어를 후속 라우트에 전달할 수 있음.




# 라우트 메서드

app.get

app.use 대신 app.get을 사용하면 경로를 사용 or 사용하지 않을수있고

들어오는 GET요청에만 작동함. ⇒ 경로 필터가 아닌 다른 형태의 필터

⇒ GET의 요청만을 걸러냄

app.post

미들웨어가 이 경로에 해당되는 POST요청의 경우만 실행 ⇒ GET요청에 반응하지 않는다.

응답 메서드

res.send() ⇒ 다양한 요청을 보내는 역할이다.

기본적으로 서버에서 response 처리를 할 때 컨텐츠 타입을 지정해야 하는데 이는 Buffer,String, Object, Array 일 수 있다.

res.redirect() ⇒ 경로의 파일을 재지정