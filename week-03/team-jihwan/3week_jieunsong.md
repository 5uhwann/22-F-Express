# week 3

- 우리의 목적
    - 사용자에게 어떤 값을 전달하는 애플리케이션 만들기
    - 서버에서 데이터를 관리하며 데이터를 동적으로 html코드에 출력하는 것 

## 요청 및 사용자 간의 데이터 공유

- 제품명 저장
    - 필드에 제품명을 저장하면, 키 title과 입력한 제품값이 콘솔에 나타난다.
    -> 그러나 지금은 저장해서 작업하고 있는것이 아니기때문에 작업하기 힘들다.
    -> 대신 JavaScript 변수에 저장해서 여러 사용자로부터 들어오는 요청들이 공유되는지 확인해볼수있다.

    - JavaScript 변수에 저장하는 방법
        ```
        const router = express.Router();

        const products = [];
        # 요소를 추가하거나 삭제해도 배열자체는 같은 객체이기 때문에 상수로 설정해도 된다.
        ```
        - 값을 저장할 변수를 추가하고, 새로운 상수로 배열을 만든다.
        ```
        exports.routes = router;
        exports.products = products;
        ```
       - router.post에 products.push로 배열에 새로운 객체 푸시.
       - 객체나 배열 같은 참조 유형을 내보내기 하고, 다른 파일에서 변결하면 변경사항은 저절로 업데이트 된다. 즉, 데이터가 공유된다는 뜻이다.
       - 실행 중인 노드 서버에 내재된 데이터(ex)여기서는 products 배열)은 사용자 간 공유된다.

# 탬플릿 엔진
- html 페이지에 동적 콘텐츠를 넣기 위해 사용하는 것.
- Node/Express Content+Templating Engine -> html과 유사한 템플릿을 스캔한 뒤 사용하고 있는 엔진 종류에 따라 플레이스홀더나 특정 스니펫을 실제 html 콘텐츠로 교체한다. 
- html 콘텐츠는 상황에 따라 해당 동적 콘텐츠를 반영하는 템플릿 엔진을 통해 서버에 생성된다. 이것들은 우리가 프로젝트로 만드는 것처럼 코딩되는 것이 아니라 상황에 따라 즉석으로 생성된다.
- ex) Node, Express 앱 내의 데이터에 대한 목록들을 html 파일 안의 순서없는 목록으로 변환해 출력할 수 있다.
    
- Node와 Express의 차이(Express가 좋은 점)
    - app.set을 사용하면 Express 애플리케이션 전체에 어떤 값이던 설정할 수 있다.

- view 엔진
    - Express에게 우리가 렌더링하려고 하는 동적 템플릿을 알린다.

- Pug
        - 실제 HTMl을 사용하지 않고 최소 버전으로 대체하고, 사용자화된(customed) 템플릿 언어를 사용해 출력한다.
        -  일단 html에서 닫는 태그가 없다 (</head>, </body>, </title> 등)
        - 들여쓰기로 어디서 부터 어디까지인지 구분하기 때문에 닫는 태그를 적을 필요가 없다.
        - 들여쓰기한 이후에 공백까지가 태그로 된다.
        - title Pug 로 쓰여있으면 title태그안에 Pug가 들어간 것을 확인할 수 있다.
        - 마찬가지로 h1 pug~~, p You are ~~ 를 봐도 다 첫번째 문자열이 태그로 들어간다.
        - 내가 원하는 태그를 넣고 싶으면 'content 123' 이런식으로 쓰면 '<content>123</content>' 가 만들어진다.
        - 태그 사이가 아닌 태그의 속성으로 넣으려면 ()괄호 사용.
        - html(lang='en') , script(type='text/javascript') 
        - 여러줄 입력할 때 ( | ) 로 작성.
        - id입력할 때 #container 처럼 #입력 (태그없을 때는 div가 자동적으로 들어가나보다)
        - 클래스는 .col 처럼 .입력

- 레이아웃
    - 레이아웃을 변경하고 싶을 때 모든 파일을 변경할 필요 없이 모든 파일에 적용한 레이아웃인 main-layout 파일만 변경하면 된다.

- Handlebars
    - HTML을 사용하지만 동적 컨텐츠의 경우 이중 중괄호 플레이스 홀더가 있다.
    ```
    <p>{{ name }}</p>
    ```
    - 일반 html과 일부 사용자 지정 구문을 사용한다.
    ```
    #표현식
    <p>{{firstname}} {{lastname}}</p>
    ```
    - 객체에 키-값 쌍을 넣어서 키와 값을 템플릿에서 사용할 수 있게 한다.

-- EJS
    - 일반 HTML을 사용하고 단순한 JavaScript를 사용할 수 있게 하는 플레이스홀더가 있다.
    ```
    <p><%= name %></p>
    ```
    - 레이아웃을 지원하지는 않는다.
        - 그대신 Partials 혹은 Includes를 사용할 수 있다. 일부 코드 블록을 템플릿 내부의 여러 부분에서 재사용한다는 개념.
            - 투입된 데이터가 바뀌지 않을 경우 완성된 템플릿의 캐시를 저장하며, 처음부터 템플릿을 다시 구축하는 것보다 빠르게 실행된다.
    - 템플릿에 js코드를 사용할수 있다.(유연성)
        - <% %>안에는 무조건 자바스트립트 코드가 들어가야한다.

## 할당 솔루션
- 데이터를 관리하고 사용자 배열 출력하기

- 그냥 배열을 만들어 작업하면 데이터는 요청 및 사용자 간 공유될것이다. 따라서 이 배열을 공유하면 안 되는 데이터를 저장하는 용도로 사용하면 안된다.

```
const users = [];

app.get('/',(req, res, next) => {
    res.render('Index', { pageTitle: 'Add User' });
});

app.post('/app-user', (req,res,next) => {
    users.push();
    res.redirect('/users');
});
```

- 이름을 추가한 후 POST 라우트에서 추출하기 위해서는 bodyParser를 불러와야한다.
```
const bodyParser = require('body-parser')

```
- 그리고 이것을 미들웨어로 등록한다. 이때 extended를 false로 설정해 오류를 방지한다.(들어오는 데이터를 분석하는 논리가 설정되어 푸시하는 새로운 객체에 name:req라는 body 속성을 준다.)

```
app.use(bodyParser({extended: false}))
```